#!/bin/bash

# Copyright (C) 2009 Andy Spencer
# See ../COPYING for terms

# GLobals
CMD=/lib/mkinit/cmd
INITCTL=/dev/initctl
PATH=/lib/mkinit/bin:/bin:/sbin:/usr/bin:/usr/sbin
export PATH

# Functions 
function usage {
cat - <<EOF
usage: $0 [options] [command]

Options:
  -h,--help    Print usage information
  -r,--relaod  Prevent spawning listeners when reloading
  -t,--test    Fake all commands

Command:
  boot         Execute boot-up procedures
  halt         Execute shutdown procedures
  reload       Re-execute init process
  mk <rule>    Execute mk rule
  start|stop|restart|zap|status <service>
               Start,stop,restart,zap or query status of service
  eval <cmd>   Execute command in mkinit process
EOF
exit
}

function runamk {
	[ "$TEST" ] && export P=true
	/usr/lib/plan9/bin/mk \
		-f /etc/init.mk \
		-i -k "$@"
}

function process {
	cmd="$1"
	shift
	args="$@"
	case "$cmd" in
	boot )
		echo
		echo "mkinit -- booting"
		runamk -a "$args"
		;;
	restart )
		if [ "$args" ]; then
			echo "mkinit -- restarting $args"
			runamk "$args-stop"
			runamk "$args-start"
		fi
		;;
	start|stop|zap|status )
		if [ "$args" ]; then
			echo "mkinit -- ${cmd}ing $args"
			runamk "$args-$cmd"
		fi
		;;
	mk|runlevel )
		if [ "$args" ]; then
			[ "$cmd" = mk ] &&
				echo "mkinit -- running mk cmd [$args]"
			[ "$cmd" = runlevel ] &&
				echo "mkinit -- entering runlevel $args"
			runamk "$args"
		fi
		;;
	reload )
		echo "mkinit -- ${cmd}ing"
		exec $0 -r ${TEST:+"-t"}
		;;
	eval )
		eval $args
		;;
	?* )
		echo "mkinit -- unknown command [$cmd $args]"
		;;
	esac
}

# Handle arguments
TEMP=`getopt -n "$0" \
	--options     hrt \
	--longoptions help,reload,test \
	-- "$@"`
[ $? != 0 ] && usage
eval set -- "$TEMP"
while true; do
	[ "$TEST" ] && echo "\$1=$1"
	case "$1" in
	-h|--help   ) usage ;;
	-r|--reload ) RELOAD=true; shift ;;
	-t|--test   ) TEST=true; shift ;;
	--          ) shift; cmd="$1";
	              shift; args="$@";
	              break ;;
	*           ) ;;
	esac
done

# Initial boot-up
process $cmd $args

if [ "$TEST" ]; then
	CMD=/tmp/pipe
	echo "Options"
	echo "  test=$TEST"
	echo "  reload=$RELOAD"
	echo "  cmd=$cmd"
	echo "  args=$args"
fi

if [ ! "$RELOAD" ]; then
	# Fork /dev/initctl listener
	( exec 0<&- 1<&- 2<&-
	initctld $INITCTL |
	while read line; do
		echo $line > $CMD
	done ) &

	# Fork console listener
	# Readline uses stdin,stderr
	( exec 1<&-;
	while true; do
		while read -e -p "mkinit> " line; do
			echo $line > $CMD
			history -s $line
		done
		[ "$TEST" ] && break
		exec 0</dev/console 2>/dev/console
		echo "Respawning on /dev/console.." >&2
		sleep 1
	done) <&0 &

	# Close stdin, stderr
	exec 0<&- 2<&-
fi

# Kill listeners on exit
trap "pkill -HUP -P $$ initctld" EXIT

# Main loop
while true; do
while read line; do
	process $line
done < $CMD
done
